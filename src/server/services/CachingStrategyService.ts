/**
 * CachingStrategyService
 *
 * Advanced caching strategies for optimal performance:
 * - Service Worker generation for offline support
 * - Cache-first, Network-first, Stale-While-Revalidate strategies
 * - Progressive Web App (PWA) support
 * - CDN configuration templates
 * - Cache versioning and invalidation
 */

// Caching strategy types
export type CachingStrategy =
  | 'cache-first'
  | 'network-first'
  | 'cache-only'
  | 'network-only'
  | 'stale-while-revalidate';

// Service Worker configuration
export interface ServiceWorkerConfig {
  cacheName: string;
  version: string;
  cacheStrategy: CachingStrategy;
  assets: CacheAssetConfig[];
  runtimeCaching: RuntimeCachingRule[];
  offlinePages: string[];
  precacheManifest?: boolean;
  skipWaiting?: boolean;
  clientsClaim?: boolean;
}

export interface CacheAssetConfig {
  pattern: string | RegExp;
  strategy: CachingStrategy;
  cacheName?: string;
  maxEntries?: number;
  maxAgeSeconds?: number;
  plugins?: CachePlugin[];
}

export interface RuntimeCachingRule {
  urlPattern: string | RegExp;
  handler: CachingStrategy;
  options?: {
    cacheName?: string;
    expiration?: {
      maxEntries?: number;
      maxAgeSeconds?: number;
    };
    backgroundSync?: {
      name: string;
      options?: {
        maxRetentionTime?: number;
      };
    };
  };
}

export interface CachePlugin {
  type: 'expiration' | 'cache-names' | 'background-sync' | 'broadcast-update';
  config: any;
}

// PWA configuration
export interface PWAConfig {
  name: string;
  shortName: string;
  description: string;
  themeColor: string;
  backgroundColor: string;
  display: 'standalone' | 'fullscreen' | 'minimal-ui' | 'browser';
  orientation: 'any' | 'portrait' | 'landscape';
  startUrl: string;
  scope: string;
  icons: PWAIcon[];
  screenshots?: PWAScreenshot[];
  categories?: string[];
  shortcuts?: PWAShortcut[];
}

export interface PWAIcon {
  src: string;
  sizes: string;
  type: string;
  purpose?: 'any' | 'maskable' | 'monochrome';
}

export interface PWAScreenshot {
  src: string;
  sizes: string;
  type: string;
}

export interface PWAShortcut {
  name: string;
  short_name?: string;
  description?: string;
  url: string;
  icons?: PWAIcon[];
}

// CDN configuration
export interface CDNConfig {
  provider: 'cloudflare' | 'fastly' | 'akamai' | 'aws-cloudfront' | 'azure' | 'custom';
  domain?: string;
  cacheRules: CDNCacheRule[];
  purgeUrls?: string[];
  headers?: Record<string, string>;
  compression?: boolean;
  minification?: {
    html?: boolean;
    css?: boolean;
    js?: boolean;
  };
  ssl?: boolean;
}

export interface CDNCacheRule {
  urlPattern: string;
  cacheTTL: number;
  browserCacheTTL?: number;
  bypassCache?: boolean;
  edgeCacheTTL?: number;
  cacheLevel?: 'bypass' | 'basic' | 'simplified' | 'aggressive';
}

// Generated output
export interface GeneratedServiceWorker {
  serviceWorkerCode: string;
  registrationCode: string;
  manifest: PWAManifest;
  size: number;
  offlineSupport: boolean;
  strategies: string[];
}

export interface PWAManifest {
  name: string;
  short_name: string;
  description: string;
  theme_color: string;
  background_color: string;
  display: string;
  orientation: string;
  start_url: string;
  scope: string;
  icons: PWAIcon[];
  screenshots?: PWAScreenshot[];
  categories?: string[];
  shortcuts?: PWAShortcut[];
}

export interface GeneratedCDNConfig {
  provider: string;
  configFiles: CDNConfigFile[];
  documentation: string;
  estimatedPerformanceGain: string;
}

export interface CDNConfigFile {
  filename: string;
  content: string;
  description: string;
}

class CachingStrategyService {
  /**
   * Generate Service Worker
   */
  generateServiceWorker(config: ServiceWorkerConfig): GeneratedServiceWorker {
    const swCode = this.generateServiceWorkerCode(config);
    const regCode = this.generateRegistrationCode(config.cacheName);
    const manifest = this.generateManifest(config);

    return {
      serviceWorkerCode: swCode,
      registrationCode: regCode,
      manifest,
      size: Buffer.byteLength(swCode, 'utf8'),
      offlineSupport: config.offlinePages.length > 0,
      strategies: this.extractStrategies(config),
    };
  }

  /**
   * Generate Service Worker code
   */
  private generateServiceWorkerCode(config: ServiceWorkerConfig): string {
    const cacheName = `${config.cacheName}-v${config.version}`;

    return `// Service Worker for ${config.cacheName}
// Generated by Website Cloner Pro
// Version: ${config.version}

const CACHE_NAME = '${cacheName}';
const OFFLINE_PAGES = ${JSON.stringify(config.offlinePages)};

// Assets to precache
const PRECACHE_ASSETS = [
${config.assets.filter(a => typeof a.pattern === 'string').map(a => `  '${a.pattern}',`).join('\n')}
];

// Runtime caching rules
const RUNTIME_CACHING = ${JSON.stringify(config.runtimeCaching, null, 2)};

/**
 * Install event - precache assets
 */
self.addEventListener('install', (event) => {
  console.log('[Service Worker] Installing...');

  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('[Service Worker] Precaching assets');
        return cache.addAll([...PRECACHE_ASSETS, ...OFFLINE_PAGES]);
      })
      .then(() => {
        ${config.skipWaiting ? 'self.skipWaiting();' : '// Skip waiting disabled'}
      })
  );
});

/**
 * Activate event - clean old caches
 */
self.addEventListener('activate', (event) => {
  console.log('[Service Worker] Activating...');

  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames
            .filter((name) => name !== CACHE_NAME)
            .map((name) => {
              console.log('[Service Worker] Deleting old cache:', name);
              return caches.delete(name);
            })
        );
      })
      .then(() => {
        ${config.clientsClaim ? 'return self.clients.claim();' : '// Clients claim disabled'}
      })
  );
});

/**
 * Fetch event - handle requests with caching strategies
 */
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Skip non-GET requests
  if (request.method !== 'GET') {
    return;
  }

  // Find matching runtime caching rule
  const rule = findMatchingRule(url.href);

  if (rule) {
    event.respondWith(handleStrategy(request, rule));
  } else {
    // Default strategy: ${config.cacheStrategy}
    event.respondWith(${this.generateStrategyCode(config.cacheStrategy, 'request', 'CACHE_NAME')});
  }
});

/**
 * Find matching caching rule
 */
function findMatchingRule(url) {
  for (const rule of RUNTIME_CACHING) {
    const pattern = typeof rule.urlPattern === 'string'
      ? new RegExp(rule.urlPattern)
      : rule.urlPattern;

    if (pattern.test(url)) {
      return rule;
    }
  }
  return null;
}

/**
 * Handle request with strategy
 */
async function handleStrategy(request, rule) {
  const cacheName = rule.options?.cacheName || CACHE_NAME;
  const handler = rule.handler;

  switch (handler) {
    case 'cache-first':
      return cacheFirst(request, cacheName, rule.options);

    case 'network-first':
      return networkFirst(request, cacheName, rule.options);

    case 'stale-while-revalidate':
      return staleWhileRevalidate(request, cacheName, rule.options);

    case 'network-only':
      return networkOnly(request);

    case 'cache-only':
      return cacheOnly(request, cacheName);

    default:
      return fetch(request);
  }
}

/**
 * Cache-first strategy
 */
async function cacheFirst(request, cacheName, options) {
  const cache = await caches.open(cacheName);
  const cached = await cache.match(request);

  if (cached) {
    console.log('[SW] Cache hit:', request.url);
    return cached;
  }

  try {
    const response = await fetch(request);

    if (response.ok) {
      const clonedResponse = response.clone();
      await cache.put(request, clonedResponse);

      // Apply expiration policy
      if (options?.expiration) {
        await applyExpiration(cacheName, options.expiration);
      }
    }

    return response;
  } catch (error) {
    console.error('[SW] Fetch failed:', error);
    return getOfflinePage();
  }
}

/**
 * Network-first strategy
 */
async function networkFirst(request, cacheName, options) {
  const cache = await caches.open(cacheName);

  try {
    const response = await fetch(request);

    if (response.ok) {
      const clonedResponse = response.clone();
      await cache.put(request, clonedResponse);

      // Apply expiration policy
      if (options?.expiration) {
        await applyExpiration(cacheName, options.expiration);
      }
    }

    return response;
  } catch (error) {
    console.log('[SW] Network failed, using cache:', request.url);
    const cached = await cache.match(request);

    if (cached) {
      return cached;
    }

    return getOfflinePage();
  }
}

/**
 * Stale-while-revalidate strategy
 */
async function staleWhileRevalidate(request, cacheName, options) {
  const cache = await caches.open(cacheName);
  const cached = await cache.match(request);

  // Fetch in background to update cache
  const fetchPromise = fetch(request).then((response) => {
    if (response.ok) {
      const clonedResponse = response.clone();
      cache.put(request, clonedResponse);

      // Apply expiration policy
      if (options?.expiration) {
        applyExpiration(cacheName, options.expiration);
      }
    }
    return response;
  });

  // Return cached version immediately if available
  return cached || fetchPromise;
}

/**
 * Network-only strategy
 */
async function networkOnly(request) {
  return fetch(request);
}

/**
 * Cache-only strategy
 */
async function cacheOnly(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cached = await cache.match(request);
  return cached || new Response('Not found in cache', { status: 404 });
}

/**
 * Apply cache expiration policy
 */
async function applyExpiration(cacheName, expiration) {
  if (!expiration) return;

  const cache = await caches.open(cacheName);
  const requests = await cache.keys();

  // Apply maxEntries
  if (expiration.maxEntries && requests.length > expiration.maxEntries) {
    const toDelete = requests.length - expiration.maxEntries;
    for (let i = 0; i < toDelete; i++) {
      await cache.delete(requests[i]);
    }
  }

  // Apply maxAgeSeconds
  if (expiration.maxAgeSeconds) {
    const now = Date.now();
    for (const request of requests) {
      const response = await cache.match(request);
      if (response) {
        const dateHeader = response.headers.get('date');
        if (dateHeader) {
          const age = (now - new Date(dateHeader).getTime()) / 1000;
          if (age > expiration.maxAgeSeconds) {
            await cache.delete(request);
          }
        }
      }
    }
  }
}

/**
 * Get offline page
 */
async function getOfflinePage() {
  const cache = await caches.open(CACHE_NAME);

  for (const page of OFFLINE_PAGES) {
    const cached = await cache.match(page);
    if (cached) {
      return cached;
    }
  }

  return new Response('Offline', {
    status: 503,
    statusText: 'Service Unavailable',
    headers: new Headers({
      'Content-Type': 'text/html'
    })
  });
}

/**
 * Message event - handle commands
 */
self.addEventListener('message', (event) => {
  if (event.data?.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }

  if (event.data?.type === 'CLEAR_CACHE') {
    event.waitUntil(
      caches.delete(CACHE_NAME)
        .then(() => {
          event.ports[0].postMessage({ success: true });
        })
    );
  }
});

console.log('[Service Worker] Loaded successfully');
`;
  }

  /**
   * Generate strategy code snippet
   */
  private generateStrategyCode(strategy: CachingStrategy, requestVar: string, cacheNameVar: string): string {
    switch (strategy) {
      case 'cache-first':
        return `cacheFirst(${requestVar}, ${cacheNameVar})`;
      case 'network-first':
        return `networkFirst(${requestVar}, ${cacheNameVar})`;
      case 'stale-while-revalidate':
        return `staleWhileRevalidate(${requestVar}, ${cacheNameVar})`;
      case 'network-only':
        return `networkOnly(${requestVar})`;
      case 'cache-only':
        return `cacheOnly(${requestVar}, ${cacheNameVar})`;
      default:
        return `fetch(${requestVar})`;
    }
  }

  /**
   * Generate registration code
   */
  private generateRegistrationCode(cacheName: string): string {
    return `// Service Worker Registration
// Add this to your main HTML file

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
      .then((registration) => {
        console.log('Service Worker registered:', registration.scope);

        // Check for updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          console.log('Service Worker update found');

          newWorker?.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New version available
              if (confirm('New version available! Reload to update?')) {
                newWorker.postMessage({ type: 'SKIP_WAITING' });
                window.location.reload();
              }
            }
          });
        });
      })
      .catch((error) => {
        console.error('Service Worker registration failed:', error);
      });
  });

  // Handle controller change
  navigator.serviceWorker.addEventListener('controllerchange', () => {
    window.location.reload();
  });
}
`;
  }

  /**
   * Generate PWA manifest
   */
  private generateManifest(config: ServiceWorkerConfig): PWAManifest {
    return {
      name: config.cacheName,
      short_name: config.cacheName,
      description: 'Progressive Web App',
      theme_color: '#ffffff',
      background_color: '#ffffff',
      display: 'standalone',
      orientation: 'any',
      start_url: '/',
      scope: '/',
      icons: [
        {
          src: '/icon-192.png',
          sizes: '192x192',
          type: 'image/png',
        },
        {
          src: '/icon-512.png',
          sizes: '512x512',
          type: 'image/png',
        },
      ],
    };
  }

  /**
   * Generate complete PWA manifest
   */
  generatePWAManifest(config: PWAConfig): string {
    const manifest = {
      name: config.name,
      short_name: config.shortName,
      description: config.description,
      theme_color: config.themeColor,
      background_color: config.backgroundColor,
      display: config.display,
      orientation: config.orientation,
      start_url: config.startUrl,
      scope: config.scope,
      icons: config.icons,
      screenshots: config.screenshots,
      categories: config.categories,
      shortcuts: config.shortcuts,
    };

    return JSON.stringify(manifest, null, 2);
  }

  /**
   * Extract strategies from config
   */
  private extractStrategies(config: ServiceWorkerConfig): string[] {
    const strategies = new Set<string>([config.cacheStrategy]);

    config.assets.forEach(asset => strategies.add(asset.strategy));
    config.runtimeCaching.forEach(rule => strategies.add(rule.handler));

    return Array.from(strategies);
  }

  /**
   * Generate CDN configuration
   */
  generateCDNConfig(config: CDNConfig): GeneratedCDNConfig {
    const files: CDNConfigFile[] = [];

    switch (config.provider) {
      case 'cloudflare':
        files.push(...this.generateCloudflareConfig(config));
        break;
      case 'aws-cloudfront':
        files.push(...this.generateCloudFrontConfig(config));
        break;
      case 'fastly':
        files.push(...this.generateFastlyConfig(config));
        break;
      default:
        files.push(this.generateGenericCDNConfig(config));
    }

    return {
      provider: config.provider,
      configFiles: files,
      documentation: this.generateCDNDocumentation(config),
      estimatedPerformanceGain: '30-70% faster load times',
    };
  }

  /**
   * Generate Cloudflare configuration
   */
  private generateCloudflareConfig(config: CDNConfig): CDNConfigFile[] {
    const files: CDNConfigFile[] = [];

    // _headers file
    const headersContent = `# Cloudflare Headers Configuration

/*
  ${Object.entries(config.headers || {}).map(([key, value]) => `${key}: ${value}`).join('\n  ')}
  Cache-Control: public, max-age=31536000
  X-Content-Type-Options: nosniff
  X-Frame-Options: SAMEORIGIN
  X-XSS-Protection: 1; mode=block

${config.cacheRules.map(rule => `${rule.urlPattern}
  Cache-Control: public, max-age=${rule.cacheTTL}
`).join('\n')}
`;

    files.push({
      filename: '_headers',
      content: headersContent,
      description: 'Cloudflare Headers configuration',
    });

    // Page Rules (JSON)
    const pageRules = {
      targets: config.cacheRules.map(rule => ({
        target: 'url',
        constraint: {
          operator: 'matches',
          value: rule.urlPattern,
        },
        actions: [
          {
            id: 'browser_cache_ttl',
            value: rule.browserCacheTTL || rule.cacheTTL,
          },
          {
            id: 'edge_cache_ttl',
            value: rule.edgeCacheTTL || rule.cacheTTL,
          },
          {
            id: 'cache_level',
            value: rule.cacheLevel || 'aggressive',
          },
        ],
      })),
    };

    files.push({
      filename: 'cloudflare-page-rules.json',
      content: JSON.stringify(pageRules, null, 2),
      description: 'Cloudflare Page Rules configuration',
    });

    return files;
  }

  /**
   * Generate AWS CloudFront configuration
   */
  private generateCloudFrontConfig(config: CDNConfig): CDNConfigFile[] {
    const cloudfrontConfig = {
      DistributionConfig: {
        CallerReference: Date.now().toString(),
        Comment: 'Website Cloner Pro CDN',
        Enabled: true,
        DefaultCacheBehavior: {
          TargetOriginId: 'origin1',
          ViewerProtocolPolicy: config.ssl ? 'redirect-to-https' : 'allow-all',
          AllowedMethods: ['GET', 'HEAD', 'OPTIONS'],
          CachedMethods: ['GET', 'HEAD'],
          Compress: config.compression !== false,
          DefaultTTL: 86400,
          MaxTTL: 31536000,
          MinTTL: 0,
        },
        CacheBehaviors: config.cacheRules.map((rule, index) => ({
          PathPattern: rule.urlPattern,
          TargetOriginId: 'origin1',
          ViewerProtocolPolicy: 'redirect-to-https',
          AllowedMethods: ['GET', 'HEAD'],
          CachedMethods: ['GET', 'HEAD'],
          DefaultTTL: rule.cacheTTL,
          MaxTTL: rule.cacheTTL * 2,
          MinTTL: 0,
        })),
      },
    };

    return [
      {
        filename: 'cloudfront-config.json',
        content: JSON.stringify(cloudfrontConfig, null, 2),
        description: 'AWS CloudFront distribution configuration',
      },
    ];
  }

  /**
   * Generate Fastly configuration
   */
  private generateFastlyConfig(config: CDNConfig): CDNConfigFile[] {
    const vcl = `# Fastly VCL Configuration
# Generated by Website Cloner Pro

sub vcl_recv {
  # Force SSL
  ${config.ssl ? 'if (!req.http.Fastly-SSL) {\n    error 801 "Force SSL";\n  }' : ''}

  # Set cache headers
  ${config.cacheRules.map(rule => `
  if (req.url ~ "${rule.urlPattern}") {
    set req.http.X-Cache-TTL = "${rule.cacheTTL}";
  }
  `).join('\n')}
}

sub vcl_fetch {
  # Set cache TTL
  if (req.http.X-Cache-TTL) {
    set beresp.ttl = std.duration(req.http.X-Cache-TTL + "s", 86400s);
  }

  # Enable compression
  ${config.compression ? 'if (beresp.http.content-type ~ "(text|javascript|json|xml|css)") {\n    set beresp.gzip = true;\n  }' : ''}
}

sub vcl_deliver {
  # Add cache status header
  if (obj.hits > 0) {
    set resp.http.X-Cache = "HIT";
  } else {
    set resp.http.X-Cache = "MISS";
  }
}
`;

    return [
      {
        filename: 'custom.vcl',
        content: vcl,
        description: 'Fastly VCL configuration',
      },
    ];
  }

  /**
   * Generate generic CDN configuration
   */
  private generateGenericCDNConfig(config: CDNConfig): CDNConfigFile {
    const content = `# Generic CDN Configuration
# Provider: ${config.provider}

## Cache Rules

${config.cacheRules.map(rule => `
URL Pattern: ${rule.urlPattern}
Cache TTL: ${rule.cacheTTL} seconds (${Math.floor(rule.cacheTTL / 3600)} hours)
Browser Cache TTL: ${rule.browserCacheTTL || rule.cacheTTL} seconds
${rule.bypassCache ? 'BYPASS CACHE' : ''}
`).join('\n')}

## Headers

${Object.entries(config.headers || {}).map(([key, value]) => `${key}: ${value}`).join('\n')}

## Features

- SSL: ${config.ssl ? 'Enabled' : 'Disabled'}
- Compression: ${config.compression ? 'Enabled' : 'Disabled'}
- Minification: ${JSON.stringify(config.minification || {})}
`;

    return {
      filename: 'cdn-config.txt',
      content,
      description: 'Generic CDN configuration',
    };
  }

  /**
   * Generate CDN documentation
   */
  private generateCDNDocumentation(config: CDNConfig): string {
    return `# CDN Configuration Guide

## Provider: ${config.provider.toUpperCase()}

### Setup Instructions

1. **Create CDN Distribution**
   ${this.getCDNSetupInstructions(config.provider)}

2. **Upload Configuration Files**
   - Upload the generated configuration files to your CDN provider
   - Follow provider-specific instructions for applying configurations

3. **Update DNS**
   - Point your domain to the CDN CNAME/endpoint
   - Wait for DNS propagation (usually 24-48 hours)

4. **Test Configuration**
   - Visit your site through the CDN
   - Check cache headers: \`curl -I https://your-domain.com\`
   - Verify cache HIT/MISS status

### Performance Expectations

- **Estimated Performance Gain:** 30-70% faster load times
- **Geographic Coverage:** Global edge locations
- **Cache Hit Ratio:** 80-95% (after warm-up period)

### Cache Rules Applied

${config.cacheRules.map((rule, i) => `
**Rule ${i + 1}:** ${rule.urlPattern}
- Cache TTL: ${Math.floor(rule.cacheTTL / 3600)} hours
- Browser Cache: ${Math.floor((rule.browserCacheTTL || rule.cacheTTL) / 3600)} hours
`).join('\n')}

### Monitoring

- Monitor cache hit ratio in CDN dashboard
- Set up alerts for cache purge operations
- Track bandwidth savings

### Purging Cache

${this.getCDNPurgeInstructions(config.provider)}
`;
  }

  /**
   * Get CDN setup instructions
   */
  private getCDNSetupInstructions(provider: string): string {
    const instructions: Record<string, string> = {
      cloudflare: `- Create a Cloudflare account
   - Add your site to Cloudflare
   - Update nameservers at your domain registrar
   - Upload _headers file to your repository`,
      'aws-cloudfront': `- Create an S3 bucket or configure origin server
   - Create a CloudFront distribution
   - Use the provided cloudfront-config.json
   - Point distribution to your origin`,
      fastly: `- Create a Fastly account
   - Create a new service
   - Upload the custom.vcl file
   - Configure backend origins`,
    };

    return instructions[provider] || '- Follow your CDN provider\'s documentation';
  }

  /**
   * Get CDN purge instructions
   */
  private getCDNPurgeInstructions(provider: string): string {
    const instructions: Record<string, string> = {
      cloudflare: 'Use Cloudflare dashboard or API:\n```\ncurl -X POST "https://api.cloudflare.com/client/v4/zones/{zone_id}/purge_cache" \\\n  -H "Authorization: Bearer {api_token}" \\\n  -H "Content-Type: application/json" \\\n  --data \'{"purge_everything":true}\'\n```',
      'aws-cloudfront': 'Use AWS CLI:\n```\naws cloudfront create-invalidation \\\n  --distribution-id {distribution_id} \\\n  --paths "/*"\n```',
      fastly: 'Use Fastly API:\n```\ncurl -X POST "https://api.fastly.com/service/{service_id}/purge_all" \\\n  -H "Fastly-Key: {api_key}"\n```',
    };

    return instructions[provider] || 'Refer to your CDN provider\'s purge documentation';
  }
}

// Export singleton instance
export default new CachingStrategyService();
